// OBJECT ORIENTED JAVASCRIPT
// What is Object Literals in JavaScript?// Object literals is simply a 'key:value' pair data structure.// Storing variables and functions together in one container.// We can refer "this" as the current object.
// ---------------------------------------------------------------------------------------------------// HOW TO CREATE AN OBJECT?
// 1st Way-// let bioData = {//   myName: "DeathSlayer",//   myAge: 9999,//   getData: function () {//     console.log(`Name : ${this.myName} and Age : ${this.myAge}`);//   },// };// Here myName is the Object literal.// We can add any kind of data into the object, even the functions.
// console.log(bioData.myName + " " + bioData.myAge);// bioData.getData();
// 2nd Way-// let bioData = {//   myName: "DeathSlayer",//   myAge: 9999,//   getData() {//     console.log(`Name : ${this.myName} and Age : ${this.myAge}`);//   },// };// After ECMAScript 2015 ES6, we can directly define the functions inside an object without using the object conventions of defining an object member in a key value pair.
// Ques : What if we want object as a member of object inside it?// Answer : YES// let bioData = {//   myfullName: {//     firstName: "Death",//     lastName: "Slayer",//   },//   myAge: 9999,//   getData() {//     console.log(//       `Name : ${bioData.myfullName.firstName}${bioData.myfullName.lastName} and Age : ${this.myAge}`//     );//   },// };// bioData.getData();
// -------------------------------------------------------------------------------// WHAT IS "this" OBJECT ?// The definition of 'this' object is that it contains the current context.// 'this' object can contains different values depending upon where it is placed.
// Example1 -// console.log(this);// It refers to the current context and in this case it is window object.
// Example2 -//   function myName() {//     console.log(this);//   };// myName();
// Example3 -//  let bioData = {//   myName: "DeathSlayer",//   myAge: 9999,//   getData: function () {//     console.log(`Name : ${this.myName} and Age : ${this.myAge}`);//   },// };
// Note : 'this' object will not work with arrow functions. with arrow functions, this object will return the window object and not the current context object.
// ---------------------------------------------------------------------------------------------------------------------// => OBJECT ORIENTED PROGRAMMING -
// 1. Object Oriented programming(OOP) is programming paradigm based on the concept of Objects.(Paradigm -> style of code, "how" we write and organize our code)// 2. We use objects to model(describe) real-world(like- user, To-Do list) or abstract features(HTML components or data structures)// 3. Objects may contains data(properties) and code(methods). By using objects, we pack data and the corresponding behaviour into one block.// 4. In OOP, objects are "self-contained" pieces/blocks of code.// 5. Objects are building blocks of applications, and interact with one another.// 6. These interaction happens through APIs(Application Programming Interface) : Methods that the code outside of an object can access and used to communicate with the other objects.// 7. OOP was developed with the goal of organizing the code,to make it more flexible and easier to maintain(and avoid "sphagetti code" -> Code without any structure)// 8. Though the most popular model of OOP is class-based. But, JavaScript isn't a classed-based language – it's a prototype-based langauge.// 9. According to Mozilla's documentaion:// A prototype-based language has the notion of a prototypical object, an object used as a template from which to get the initial properties for a new object.
// ---------------------------------------------------------------------------------------------------------------------// => CLASSES AND INSTANCES -
// - Some features or mechanisms which makes a Language Object-Oriented like:// - Object(Instance)// - Classes// - Fundamental principles of OOP (4 Pillars of OOP):// 1. Abstraction// 2. Polymorphism// 3. Encapsulation// 4. Inheritance
// - ABSTRACTION -// - Ignoring or Hiding details that doesn't matter, allowing us to get an overview perspective of the thing we are implementing, instead of messing with the details that don't really matter to our implementation.
// - POLYMORPHISM -// - Polymorphism is nothing but one type but many forms. One type of object can behave differently depending upon the runtime scenario. Polymorphism uses the concept of Inheritance to achieve this. In polymorphism, multiple objects will have the same method but different implementation and depending upon the user preference the corresponding object will be selected and the method corresponding to that object will be executed.// - Polymorphism allows us to define the same method in different objects and provides the ability to call them depending upon the object.
// - ENCAPSULATION -// - Keepings properties and methods private inside the class, so they are not accessible from outside the class. Some methods can exposed as Public Interface(APIs)// - This prevents any external code from accidentlly manipulating the internal properties/state.
// - INHERITANCE -// - Making all properties and methods of a certain class available to the child class, forming a hierarchical relations between classes. This allows us resuse common logic and remodel real-world relationships
// ---------------------------------------------------------------------------------------------------------------------// - OBJECTS -
// - Objects(Instances) are instantiated from a class, which functions like a blueprint.// - And Objects in JS are linked to a Prototype Object.This prototype contains methods(behaviour) that are acccessible to all objects linked to that prototype and this MECHANISM is called as Prototypal Inheritance. And This can also be said as -> Object behaviour(methods) is delegated(Prototypal Inheritance = Delegation) to the linked Prototype Object.// – An Object is a unique entity that contains property and methods. For example “car” is a real life Object, which has some characteristics like color, type, model, horsepower and performs certain action like drive. The characteristics of an Object are called as Property, in Object-Oriented Programming and the actions are called methods. An Object is an instance of a class. Objects are everywhere in JavaScript almost every element is an Object whether it is a function, array, and string.// - Note: A Method in javascript is a property of an object whose value is a function.// - Note: OOP in JS is applied using Prototypal Inheritance and not using the conventional classes
// QUESTION -// 1. How do we actually create prototypes?// 2. How we actually link objects to prototypes?// 3. How can we create objects without having classes through which we instantiates our objects?// ANS - There are 3 Ways of Implementing Prototypal Inheritance in JavaScript -
// - 3 WAYS OF IMPLEMENTING PROTOTYPAL INHERITANCE -// 1. Constructor Functions -// - Technique to create objects from a function.// - This is how built-in objects like - Arrays, Maps, Sets are actually implemented.// - This is how OOP is done in JS since the beginning.
// 2. ES6 Classes -// - Modern Alternative to constructor function syntax.// - Though these are not real classes but just a "Syntactic sugar" : behind the scenes, ES6 classes work exactly like constructor functions.// - ES6 classes DO NOT behave like a classical OOP classes.
// 3. Object.create() method -// - The easiest and the most straightforward way of linking an object to a prototype object.
// NOTE: The 4 Pillars of OOP are still valid in JS OOP Prototypal Inheritance.
// ---------------------------------------------------------------------------------------------------------------------// - CLASSES –
// - Classes are blueprint of an Object. A class can have many Object, because class is a template while Object are instances of the class or the concrete implementation.// - Before we move further into implementation, we should know unlike other Object Oriented Language there is no classes in JavaScript we have only Object. To be more precise, JavaScript is a prototype based object oriented language, which means it doesn’t have classes rather it define behaviors using constructor function and then reuse it using the prototype.// - Note: Even the classes provided by ECMA2015 are objects.// - JavaScript classes, introduced in ECMAScript 2015, are primarily syntactical sugar over JavaScript’s existing prototype-based inheritance. The class syntax is not introducing a new object-oriented inheritance model to JavaScript. JavaScript classes provide a much simpler and clearer syntax to create objects and deal with inheritance.
// ---------------------------------------------------------------------------------------------------------------------// (CLASSICAL OOPS: CLASSES) VS (OOP IN JS: PROTOTYPES) -
//                 CLASSES                                                     PROTOTYPES// 1. Classes  ->  Instantiates ->   Objects            Prototypes   <- Prototypal Inheritance/Delegation  <- Objects// 2. Objects are instantiated from a class, which      Objects are linked to a prototype Object//   Functions like a blueprint.// 3. Behaviour(method) are copied from class to        Behaviour(method) are delegated to linked prototype// all the instances(objects)                           object. Prototype contains the methods and objects can//                                                      access those methods through delegation
// ---------------------------------------------------------------------------------------------------------------------// => 1. CONSTRUCTOR FUNCTION AND THE NEW OPERATOR -
// - In JavaScript, a constructor function is used to create objects.// - To create an object from a constructor function, we use the new keyword.// - We cannot create a function constructor using the arrow function because arrow functions do not have their own "this" value.// - When "this" keyword is used in a constructor function, this refers to the object when the object is created.// - Object Literal is generally used to create a single object. The constructor function is useful if you want to create multiple objects.// - The main difference between object literal and constructor functions is that it is easy to create multiple objects with the same properties using constructor functions than with object literals.// - In Constructor Functions, We can add or remove properties/methods to a particular object without mutating the orginal constructor functions properties/methods. However, if an object is created with an object literal, and if a variable is defined with that object value, any changes in variable value will change the original object.
// Note: It is considered a good practice to capitalize the first letter of your constructor function.
// - What does the new Operator do ?// - The new operator does these 4 steps -// 1. Create a new empty object -> {}// 2. Then function we created is called and in the execution context of the function, the "this" value of the function will be set to this newly created empty object. this -> {}// 3. The newly created empty object is linked to the prototype object. (which creates __proto__ property and sets its values to the property of the function that is being called)// 4. In the end, the function called will automatically returns the empty object {}
const Person = function (firstName, birthYear) {  // This will print the empty object of Person(from Step-1 & Step-2) we just created using new operator  console.log(this);
  // Creating and setting properties/methods in the "this"(current) object.  // this.propertyName = propertyValue; => Called Instance properties  this.firstName = firstName;  this.birthYear = birthYear;
  // this.methodName = function(){body} => Called Instance methods  // But never create method like this, as this is considered as really bad practice.  this.calcAge = function () {    console.log(2037 - this.birthYear);  };};
// Right of the assignment Operator => Creating a Person object using the new Operator// Left of the assignment Operator => Storing the returned value(Step-4) from the constructor function in a variable.const jonas = new Person("Jonas", 1991);const matilda = new Person("Matilda", 1993);const jack = new Person("Jack", 1992);
// Here, we created 3 instances/objects of the Person constructor function
const jay = { firstname: "Jay", birthYear: 2001 };// - We can check of whether a particular object is an instance of constructor function/ES6 Class or not using the "instanceof" operatorconsole.log(matilda instanceof Person);console.log(jack instanceof Person);console.log(jay instanceof Person);
// Adding lastName property to jack objectjack.lastName = "robin";console.log(jack);
// Note :// 1. Never create methods inside a Constructor Function as it is considered a really bad practice because suppose if we are creating thousands of objects of this constructor function then the methods created in the constructor function would be carried with those thousands of objects created(a thousand copies of those methods will be carries around) and that will create a toll on the performance of our application.// 2. To Solve this problem, we will use prototypes and prototypal inheritance.// 3. Constructor Functions are not really a feature of JavaScript languange, instead is a programming pattern that was developed by other developers
// ---------------------------------------------------------------------------------------------------------------------// => JAVSCRIPT BUILT-IN CONSTRUCTORS -
// - JavaScript also has built-in constructors. Some of them are:// let a = new Object(); // A new Object object// let b = new String(); // A new String object// let c = new Number(); // A new Number object// let d = new Boolean(); // A new Boolean object// let d = new Array(); // A new Array object// let d = new Map(); // A new Map object// let d = new Set(); // A new Set object
// Note:// - It is recommended to use primitive data types and create them in a normal way, such as -//  const name = 'John';, const number = 57; and const count = true;// - You should not declare strings, numbers, and boolean values as objects because they slow down the program.
// ---------------------------------------------------------------------------------------------------------------------// PROTOTYPES -
// - Each and every function in JavaScript automatically has a property called PROTOTYPE.// - Every function and object has a property named prototype by default.// - A prototype can be used to add properties and methods to a constructor function. And objects inherit properties and methods from a prototype. And this is call Prototypal Inheritance or Prototype Inheritance// - Every object that is created by a certain constructor function would get access to all the methods and properties that we define on the constructor's prototype property.// - Prototype is used to provide additional property to all the objects created from a constructor function.// - You can also add new methods to a constructor function using prototype. (This is the appropriate way to create methods in Constructor Functions. Because this way, only one copy of the method is created which is accessible to all the objects created.)
// - Syntax :// - objectConstructorName.prototype.propertyName(key) = propertyValue// - objectConstructorName.prototype.methodName(key) = function() {body}
// EXAMPLE -// const Person = function (firstName, lastName, birthYear) {//   this.firstName = firstName;//   this.lastName = lastName;//   this.birthYear = birthYear;
//   // We are trying to access the prototype property of a Person constructor function.//   // Since the prototype property has no value at the moment, it shows an empty object//   console.log(Person.prototype);
//   // Creating a method using prototype property//   Person.prototype.calcAge = function () {//     console.log(2037 - this.birthYear);//   };
//   // Logging prototype property of Person Constructor Function//   console.log(Person.prototype);// };
// const jonas = new Person("Jonas", "Brick", 1991);
// - Here we can see in the log that the method we created using Prototype property is not attached on the object itself.// console.log(jonas)
// - Still we can use the calcAge() Method using our object even though it is in the object Itself because of the Prototypal Inheritance.// jonas.calcAge();
// Note :// -  If a prototype value is changed, then all the new objects will have the changed property value. Though all the previously created objects will have the previous value.// - A __proto__ property gets attached to the object when we are creating the object using constructor function (Step-3 of the object creation using the new Operator)// - __proto__ is the actual object that is used in the lookup chain to resolve methods, etc. prototype is the object that is used to build __proto__ when you create an object with new.So prototype is not available on the instances themselves (or other objects), but only on the constructor functions.// - prototype is a property of a Function object. It is the prototype of objects constructed by that function. Whereas __proto__ is an internal property of an object, pointing to its prototype.// console.log(jonas.__proto__)// console.log(jonas.__proto__ === Person.prototype) // true// console.log(Person.prototype.isPrototypeOf(jonas)); // true// console.log(Person.prototype.isPrototypeOf(Person)); // false
// ---------------------------------------------------------------------------------------------------------------------// => HOW PROTOTYPAL INHERITANCE(DELEGATION) WORKS -
// EXAPLAINATION -// To explain it more clearly -// 1. A prototype property is created when a function is declared.
//  function Person (name) {//   this.name = name;//  }
// 2. When JavaScript executes this code, it adds prototype property to Person(Constructor Function), prototype property is an object with two bydefault properties to it:// a. constructor// b. __proto__
// So,  when we executes or console.log(Person.prototype) it returns://  constructor: a  // function definition//  __proto__: Object
// 3. Now as you can see constructor is nothing but the function Person itself and __proto__ points to the root level Object of JavaScript.
// - This means the constructor function refrences to the prototype property and the prototype property references back to the constructor// - The __proto__ property also references to the prototype property
// 4. Let us see what happens when we use a function with new key word -// const jonas = new Person ('Jonas');
// => When JavaScript executes this above line of code it does 4 things:// Step#1 - It creates a new object, an empty object // {}// Step#2 - It creates __proto__ on jonas and makes it point to Person.prototype.So,//  jonas.__proto__ === Person.prototype// Step#3 - It executes Person.prototype.constructor (which is definition of function Person) with the newly created object (created in step#1) as its context (this), hence the name property passed as 'Jonas' (which is added to this) gets added to newly created object.// Step#4 -  It returns newly created object in (created in step#1) so variable jonas gets assigned to newly created object.
// Note:// 1. Other properties/methods are also attached to this prototype property which were created using prototype property.// 2. The same mechanism works in ES6 classes also.// 3. It is worth noting that Person.prototype is an Object literal by default (it can be changed as required).
// => PROTOYPE CHAIN -// - Now if we also add properties on the Prototype directly// Person.prototype.species = "Home Sapiens"// and now if we executes jonas.species, the output "Homo Spaiens" appears.
// - This is because when JavaScript executed this code it searched for species property on jonas instance, it did not find any property names species on jonas instance then JavaScript used jonas.__proto__ (which was made to point to 'Person.prototype' in step#2) and finds species property in the prototype property and so return "Homo Sapiens". and This behaviour/mechanism we just described here is what we call Prototypal Inheritance or Delegation.
// - The ability of looking up methods and properties in a prototype is what we call the Prototype Chain.// - But actually the prototype chain does not end here.
// => PROTOTYPE CHAIN EXPLANATION -// - We know that [Person.prototype](constructor instance/object prototype) property is an object itself and remember that every object in JavaScript have a prototype. That means [Person.prototype] must also have a prototype.// - So, the prototype (__proto__ property) [Person.prototype] references to the [Object.prototype] meaning prototype of [Person.prototype] is [Object.prototype] -> __proto__: Object.prototype// - Since, we know that [Person.prototype] is an object then it must be created using some Constructor Functions Right? So, that constructor function is Built-in [Object()] Constructor Function and so the [Object.prototype] is the prototype of [Person.prototype] object. Just like the [jonas] object is created by the [Person()] Constructor Function and so the [Person.prototype] is the prototype of [jonas] -> __proto__ : Person.prototype// - This Entire series of Links between objects linked through the prototypes is called Prototype Chain. And [Object.prototype] is always at the top of the chain and its prototype is null. So, Its, __proto__ property simply points to null which marks the end of the prototype chain -> __proto__ : null
// - So, in a certain way the Prototype Chain is very similar to the Scope Chain but with prototypes.// - So, in the Scope Chain whenever JavaScript can find a certain variable in a certain scope, it looks up into the next scope and a scope chain and tries to find the variable there.// - On the other hand in the Prototype Chain whenever JavaScript can find a certain property or method in a certain object it's gonna look up into the next prototype in the prototype chain and see if it can find it there,
// Note: This built-in Object() constructor function is the one which is used when we create object using Object Literals.// {...} === new Object();
// => PRORPERTY/METHOD LOOKUP -// - Now let's actually see another example of a method lookup. To do that we call the has own property method on the [jonas] object.// - We can check if a property belongs to an instance or not using the hasOwnProperty() method -// console.log(jonas.hasOwnProperty("name")) // true// console.log(jonas.hasOwnProperty("species")) // false
// => EXPLAINATION -// - JavaScript is gonna start by trying to find the called method (hasOwnProperty() in this case)on the object itself. But of course it can't find the has own property method on [jonas]. So, according to how the prototype chain works, it will then look into its prototype which is person dot prototype.// - Now, we didn't define any has own property method there either and so a JavaScript is not gonna find it there and so therefore it will move up even further in the prototype chain and now look into object dot prototype and object dot prototype does actually contain a bunch of built in methods and has own property is one of them.// - So JavaScript can then take this one and run it on the jonas object as if has own property had been defined  directly on Jonas. And remember the method has not been copied  to the jonas object. Instead, it simply inherited the method from object dot prototype through the prototype chain and that's actually it.
// console.log(jonas.__proto__); // will print [Person.prototype]// console.log(jonas.__proto__.__proto__); // will print [Object.prototype]// console.log(jonas.__proto__.__proto__.__proto__); // will print [null]
// console.dir(Person.prototype.constructor); // will print Person Constructor function// console.dir(Object.prototype.constructor); // will print Object Constructor function// console.dir(jonas.__proto__.__proto__.constructor); // will Object Constructor function
// ---------------------------------------------------------------------------------------------------------------------// => PROTOTYPAL INHERTANCE IN BUILT-IN OBJECTS -
// Note- Functions, Arrays, Maps, Sets, Math, String, Date, DOM Elements are all built-in objects in JS.
// 1. Arrays -// const arr = [1, 4, 1, 2, 2, 3, 4, 5]; // same as-> new Array() === []// console.log(arr.__proto__ === Array.prototype); // true// console.log(arr.__proto__); // will print Array Function properties// console.log(arr.__proto__.__proto__); // will print Object Function properties// console.log(arr.__proto__.__proto__.__proto__); // will print null
// - We can also extend the functionality of Built-In Object using their prototype properties -// Example : We can extend the functionality of Array like this -// Array.prototype.unique = function () {//   return [...new Set(this)];// };// - This will return the unique elements of the array on which this method is applied using the dot operator.// console.log(arr.unique()); // [1, 4, 2, 3, 5]
// 2. DOM ELEMENT -// const h1 = document.createElement("h1");// console.dir(h1); // We can check its Prototype Chain in Browser as it is a huge one.// - But, In General, The Prototype Chain of DOM Elements looks like This -// - DOM Element -> HTMLHeadingElement -> HTMLElement -> Element -> Node -> EventTarget -> Object -> null
// console.log(h1.__proto__); // Will print HTMLHeadingElement Function Properties
// 3. Functions -// console.dir(x => x + 1)// Since this X is also a function a prototype is also attached to it and we can this in the console in browser.
// const y = () => 1 + 1;// console.dir(y)// console.dir(y.__proto__) // Will print Function Prototype properties// console.dir(y.__proto__.__proto__) // Will print Object Prototype properties
// 3. Same can be applied to Other built-In Objects like - Functions, Maps, Date, Strings etc.
// ---------------------------------------------------------------------------------------------------------------------// 2. ES6 CLASSES -
// - The traditional class as the blueprint to create objects, used in languages like Java or Swift, does not exist in JavaScript. The prototypal inheritance deals only with objects.
//  - The prototypal inheritance can emulate the classic class inheritance. To bring the traditional classes to JavaScript, ES2015 standard introduces the class syntax: a syntactic sugar over the prototypal inheritance.It continues its prototyping in the background but makes the outer body look like OOP -> Meaning it works the same as Constructor Functions.
// There are two ways for defining a class in JavaScript -// 1. Class Declaration -// class NameOfClass {//   constructor(constructor arguments){//   }// }
// 2. Class Expression -// const NameOfClass = class {//   constructor(constructor arguments){//   }// }
// - Defining methods in classes -// class PersonCl {//   constructor(firstName, lastName, birthYear) {//     this.firstName = firstName;//     this.lastName = lastName;//     this.birthYear = birthYear;//   }// Methods will be added to the .prototype property of the object//   calcAge() {//     console.log(2047 - this.birthYear);//   }// }
// Note - Methods of the class will be automatically added to the [Prototype] property of the class and will be addd to __proto__(now -> [[Prototype]]) property of the object.
// - Creating an Instance of this class using the new operator.// const jessica = new PersonCl("Jessica", "Jones", 1991);// console.log(jessica);// console.log(jessica.__proto__ === PersonCl.prototype); // true// - This is the proof that the class just hides the Prototypal Inheritance behaviour of JavaScript and is truly prototyping in nature behind the scenes.
// - Adding Method manually outside of a class -// PersonCl.prototype.greet = function () {//   console.log(`Hey ${this.firstName} ${this.lastName}`);// };
// - Calling the manually added method using an instance -// jessica.greet();
// Note:// 1. A class should be defined before using it. Unlike functions and other JavaScript declarations, the classes are not hoisted in JavaScript.// 2. Just Like Functions, Classes are also First Class Citizens in JavaScript. Because in reality, classes are just special kinds of function in JavaScript. The// 3. Classes always get executed in "Strict Mode". It doesn't matter whether we have defined the "use strict" mode or not in our script.
// ---------------------------------------------------------------------------------------------------------------------// => SETTERS AND GETTERS -
// - In JavaScript, there are two kinds of object properties:// 1. Data properties// 2. Accessor properties
// 1. Data Property - These are the properties that are set and accessed directly using the instance.// const student = {//     // data property//     firstName: 'Monica';// };
// 2. Accessor Property -// In JavaScript, accessor properties are methods that get or set the value of an object property. For that, we use these two keywords:// get - to define a getter method to get the property value// set - to define a setter method to set the property value
// A - Getter Methods -// - In JavaScript, getter methods are used to access the properties of an object.// - To create a getter method, the get keyword is used.// Example -// const student = {//   // data property//   firstName: "Monica",
//   // accessor property(getter)//   get getName() {//     return this.firstName;//   },// };
// // accessing data property// console.log(student.firstName); // Monica
// // accessing getter methods like property just like any other data property// console.log(student.getName); // Monica
// // If we try to access as a method then we'll get error// console.log(student.getName()); // error
// B - Setter Methods -// - In JavaScript, setter methods are used to change the values of an object.// - To create a setter method, the set keyword is used.// - Setter must have exactly one formal parameter.// Example -// const student = {//   firstName: "Monica",
//   // accessor property(setter)//   set changeName(newName) {//     this.firstName = newName;//   },// };
// console.log(student.firstName); // Monica
// // changing(setting) object property using a setter just like any other data property// student.changeName = "Sarah";
// console.log(student.firstName); // Sarah
// - GETTERS AND SETTERS IN CLASSES -// - JavaScript classes may include getters and setters. You use the get keyword for getter methods and set for setter methods.// Example -// class Person {//     constructor(name) {//         this.name = name;//     }
//     // getter//     get personName() {//         return this.name;//     }
//     // setter//     set personName(x) {//         this.name = x;//     }// }
// let person1 = new Person('Jack');// console.log(person1.name); // Jack
// // changing the value of name property// person1.personName = 'Sarah';// accessing the name using a getter// console.log(person1.personName); // Sarah
// => WHY GETTERS AND SETTERS -// - Getters and Setters are actually useful in data validation cases.// - If we are setting the same property using the data property and setter method. Then we will get error, because there is conflict between constructor and setter method over setting the same property value. So, to tackle this we create a new property by prepending "_" to the property name(_name) in setter while setting its value. Though it will create a new property name with that _name. But, we will be able to access it will the same getter name we created for the same property name and we will also be able to validate our data.// - When setting the property names with data properties and setter properties, setter properties takes priority for setting the same property.
// Example -
// const PersonCl = class {//   constructor(fullName, birthYear) {//     this.fullName = fullName; // Line-1//     this.birthYear = birthYear;// }
// Note: Whenever constructor is called and try to set the fullName value by executing Line-1, then instead of this the setter method gets executed always to set the fullName. So fullName parameter of the function becomes the name parameter of the fullName(name) setter method.
// Validating fullName using setter method for fullName// This fullname(name) setter is getting its name parameter from the constructor fullName property.// set fullName(name) {//   // Setting a new property name using the underscore//   if (name.includes(" ")) this._fullName = name;//   else alert(`${name} is not a full name`);// }
// Getting the fullName using the same property name//   get fullName() {//     return this._fullName;//   }// };
// const johny = new PersonCl("Johny Walter", 1991);// const akbar = new PersonCl("Akbar", 1991);
// console.log(johny);// console.log(akbar);
// console.log(johny.fullName);// console.log(akbar.fullName);
// --------------------------------------------------------------------------------------------------------------------// => STATIC FIELDS/METHODS -
// - The static methods are functions attached directly to the Class OR Constructor Function and does not get attacahed to the prototype property. They hold logic related to the Class or Constructor Function, rather related to thier instances.// - When working with static methods, there are 2 simple rules to remember:// 1. A static method can access static fields// 2. A static method cannot access instance fields
// - Static Method in Constructor Functions -// - We use Constructor functions name along with dot operator to the method name to create a static method or field// - Syntax - ConstructorFunctionName.methodName()// - Syntax - ConstructorFunctionName.fieldName
// Example -// const PersonCf = function (firstName, birthYear) {// instance properties/fields// this.firstName = firstName;// this.birthYear = birthYear;
// Static field/property// PersonCf.species = "Homo Sapiens";
// instance method// PersonCf.prototype.calcAge = function () {//   console.log(2037 - this.birthYear);// };
// static method//   PersonCf.hey = function () {//     console.log("Hey There ");//   };// };
// const person1 = new PersonCf("Death", 8888);// console.dir(PersonCf);// PersonCf.hey();// console.log(PersonCf.species);// console.log(jonas.hey()) // This will throw an error since static properties/methods are not inherited
// - Static Methods in Classes -// - We use static key before method name to create a static method or field// - Syntax - static methodName()// - Syntax - static fieldName
// Example -// const PersonCl = class {//   constructor(firstName, birthYear) {//     // instance properties/fields//     this.firstName = firstName;//     this.birthYear = birthYear;//   }
//   // Static field/property//   static species = "Homo Erectus";
//   // instance method//   calcAge() {//     console.log(2099 - this.birthYear);//   }
//   // static method//   static hey() {//     console.log("Hey There from static method ");//   }// };
// const person2 = new PersonCl("Alex", 9999);
// console.dir(PersonCl);// PersonCl.hey();// console.log(PersonCl.species);// person2.hey(); // Will throw an error since hey() is static ans is not attached to any instance
// ---------------------------------------------------------------------------------------------------------------------// 3. Object.create() METHOD -
// - Object.create() method is used to create a new object with the specified prototype object and properties. Object.create() method returns a new object with the specified prototype object and properties.// - We can use Object.create() method to essentially manually set the prototype of an object, to any other object that we want.// - Object.create builds a new object that inherits from the object that is passed as its first argument (it can be only either an object or null).
// - Applications -// Object.create() is used for implementing inheritance.
// - Syntax -// Object.create(prototype, [propertiesObject])
// - Parameters Used -// - prototypeObject : It is the prototype object from which a new object has to be created. It has to be an object or null.// - propertiesObject : It is optional parameter. It specifies the enumerable properties to be added to the newly created object. If specified and not undefined, an object whose enumerable own properties (that is, those properties defined upon itself and not enumerable properties along its prototype chain) specify property descriptors to be added to the newly-created object, with the corresponding property names. These properties correspond to the second argument of Object.defineProperties(). Basically, propertiesObject is used to create properties on a new object. It acts as a descriptor for the new properties to be defined. Descriptors can be data descriptor or access descriptors.
// Data descriptors are -// - configurable// - enumerable// - value// - writable
// Access descriptors are -// - get// - set
// - Return Value -// Object.create() returns a new object with the specified prototype object and properties.
// Example -// Object Literal// const PersonProto = {//   form: "Humanoid",//   species: "Homo Sapiens",//   greet() {//     console.log("Hey there ");//   },// };
// => HOW Object.create() WORKS -// - Creating a new Prototype Object that will be attached to person1 and which will inherit from PersonProto object.// - This object.create() will return a brand new object that is linked to a prototype object that we passed into this as a formal parameter. In this case, PersonProto will become a prototype object for person1 object.// - The big difference between this Object.create() and Constructor Function is that, unlinke Constructor Functions we don't need any Constructors or prototype properties to create a prototype object for an object.// const Person = Object.create(PersonProto);// console.log(PersonProto);// console.log(Person);
// - Creating and Setting the Person properties// Person.firstName = "John";// Person.lastName = "Doe";// console.log(Person);
// - Calling the prototype object property we have attached to our new object.// Person.greet();
// - Checking if PersonProto which we attached to our object as prototype is real or not -// console.log(Person.__proto__);// console.log(Person.__proto__ === PersonProto);
// - Better way of Setting the Object properties would be using a function -// - So, we will create our own function that behaves in a way like a constructor do.// -  For that we are creating an init() in the PersonProto1 Object Literal and object our Prototype Object is created(In this case Person2), we will initialize Person2 properties using the init() method.
// Example -// const PersonProto1 = {//   form: "Humanoid",//   species: "Homo Sapiens",//   greet() {//     console.log("Hey there ");//   },//   init(firstName, lastName) {//     this.firstName = firstName;//     this.lastName = lastName;//   },// };
// Object Person2 with PersonProto1 Prototype will be created// const Person2 = Object.create(PersonProto1);// console.log(PersonProto1);// console.log(Person2);
// Initializing its property using init() methods// Person2.init("Sarah", "Williams");// Person2.greet();// console.log(Person2);
// ---------------------------------------------------------------------------------------------------------------------// => INHERITANCE IN JAVASCRIPT OBJECT-ORIENTED PROGRAMMING (OOP) -
// - In object-oriented programming, inheritance is the mechanism of basing an object or class upon another object (prototype-based inheritance) or class (class-based inheritance), retaining similar implementation.// - An inherited class is called a subclass of its parent class or super class.// - In most class-based object-oriented languages, an object created through inheritance, a "child object", acquires all the properties and behaviors of the "parent object" , with the exception of: constructors, destructor, overloaded operators and friend functions of the base class.// - Inheritance allows programmers to create classes that are built upon existing classes,[1] to specify a new implementation while maintaining the same behaviors (realizing an interface), to reuse code and to independently extend original software via public classes and interfaces.
// - So, As we know that Prototypal Inheritance(Prototyping) can be done using// 1. Constructor Functions// 2. ES6 Classes// 3. Object.create() Method
// - Inheritance in "Classes" Can take place in all 3 Prototypal Inheritance. (Using the term "Class" here and moving forward in case of Inheritance to make is easier to understand. In reality, this inheritance acutally means Inheriting properties/methods from other Prototype-Based Objects created using Constructor Functions, Classes, and Object.create() Methods)
// ---------------------------------------------------------------------------------------------------------------------// 1. INHERITANCE BETWEEN CLASSES: CONSTRUCTOR FUNCTIONS -
// - We can use inheritance in the Child Constructor Functions by Calling the Parent Constructor Function using the call() method which also sets the "this" value of the child object to the Parent Constructor Function . Because, if we simply call the Parent Constructor Function, then the Parent Constructor Function will not be able to set the Child Constructor Function properties as it is getting is value directly and not using the new operator which usually sets the "this" of any Constructor Function. Hence, Parent Constructor Function will get undefined in place of "this" value wherever in the Parent Constructor Function it is used.// - And To Inherit the Parent Constructor Function methods also. We need to set the __proto__([[Prototype]]) property of the Child Constructor Function set to the [Parent.prototype] otherwise Child Constructor Functions wont be able to inherit the Parent Constructor Function methods. And we can do this by using Object.create() method And add the Prototype property of Parent Constructor Functions to the Prototype Chain of the Child Constructor Function.
// Example -// Parent Constructor Function (Parent "Class")// const Person = function (firstName, birthYear) {//   this.firstName = firstName;//   this.birthYear = birthYear;
//   Person.prototype.calcAge = function () {//     console.log(2077 - this.birthYear);//   };// };
// Child Constructor Functions (Child "Class")// const Student = function (firstName, birthYear, course) {// Trying to set the firstName and birthYear using the Parent "Class"// But it will throw an error, because the Person(Parent) "Class" doesn't have the value of "this" which is usually set when the object is created using the new Operator but here we are calling it without it.// Person(firstName, birthYear);
// So, we have to pass the value of "this" of the current object also in order for this to work and we know that we can do this with the help of call() method of Functions Objects. Using the call() method, we can call the Person Constructor Function and manually set the value of "this" also.//   Person.call(this, firstName, birthYear);//   this.course = course;
//   Student.prototype.introduce = function () {//     console.log(`My name is ${this.firstName} and I study ${this.course}`);//   };// };
// LINKING PROTOTYPES// So, Now we can also call the Parent Constructor Function methods also as they gets inherited from them after prototype linking.// Student.prototype = Object.create(Person.prototype);
// - linking child prototype back to its Constructor (Otherwise it will point to Parent Constructor because of Object.create() method-// Student.prototype.constructor = Student;
// Note: We should do the linking of the prototypes just after when we define our Child Constructor Function. Because our Object.create() methods returns an empty object which can later be filled with manually child class methods outside of the Child Constructor Function. But if do it the other way around then our manually created child class methods will get overriden and any methods before linking the prototypes will not be added to the prototype property of child.
// const mike = new Student("Mike", 1991, "Btech(CSE)");// console.log(mike);// mike.introduce();// mike.calcAge();
// console.log(mike instanceof Student); // true// console.log(mike instanceof Person); // true// console.log(mike instanceof Object); // true// This means out Prototype Chain has been set correctly.
// console.dir(Student.prototype.constructor);// Constructor is also set correctly
// console.log(mike.__proto__);// console.log(mike.__proto__.__proto__);// console.log(mike.__proto__.__proto__.__proto__);// console.log(mike.__proto__.__proto__.__proto__.__proto__);// Checking Prototypes
// ---------------------------------------------------------------------------------------------------------------------// 2. INHERITANCE BETWEEN CLASSES: ES6 CLASSES -
// - The classes in JavaScript support single inheritance using the extends keyword.// - This extends keywords links the prototypes of Child and Parent Classes behind the scenes.// - In the JavaScript expression class Child extends Parent { } the Child class inherits from Parent the constructor, fields, and methods.// - Note that private members of a parent class are not inherited by the child class.// - Note that inside the child constructor you must execute super() before using this keyword. Calling super() makes sure that the parent constructor initializes the instance.// - If you'd like to access the parent method inside of a child method, you can use the special shortcut super.// - If the arguments in the Child class and Parent class are exactly same then we don't need to use the constructor in the child class at all. The super() method will be automatically to set those parameters from the Parent Class Constructor.// - Otherwise, super() method always needs to be called first before anything in the constructor. As the super() is responsible for accessing the "this" value in the derived classes.
// Example -// class PersonCl {//   constructor(firstName, lastName, birthYear) {//     this.firstName = firstName;//     this.lastName = lastName;//     this.birthYear = birthYear;//   }//   // Methods will be added to the .prototype property of the object//   calcAge() {//     console.log(2047 - this.birthYear);//   }// }
// PersonCl.prototype.greet = function () {//   console.log(`Hey There `);// };
// class StudentCl extends PersonCl {//   constructor(firstName, lastName, birthYear, course) {//     // This super() method always needs to be called first before anything in the constructor. As the super() is responsible for accessing the "this" value in the derived classes.//     super(firstName, lastName, birthYear);//     this.course = course;//   }
//   introduce() {//     console.log(//       `My name is ${this.firstName} ${this.lastName} and I study ${this.course}`//     );//   }// }
// const emily = new StudentCl("Emily", "Heart", 1997, "Psychology");// console.log(emily);// emily.greet();// emily.introduce();// emily.calcAge();
// ---------------------------------------------------------------------------------------------------------------------// 3. INHERITANCE BETWEEN CLASSES: Object.create() Method -
// - Inheritance in Object.create() Methods are quite simple.// - When creating a Parent object using the Object Litrals as Prototype of the object, we just have to create a Student Object using the Parent Object as the Prototype of the child object.
// Example -// OBject Lietral// Parent Object// const PersonProto = {//   form: "Humanoids",//   species: "Neantherdals",
//   calcAge() {//     console.log(2037 - this.birthYear);//   },
//   init(firstName, lastName, birthYear) {//     this.firstName = firstName;//     this.lastName = lastName;//     this.birthYear = birthYear;//   },// };
// - Creating Child Object using Parent Object as prototype -// const StudentProto = Object.create(PersonProto);
// - Initializing / Setting properties in the StudentProto (Child) object -// StudentProto.init = function (firstName, lastName, birthYear, course) {//   PersonProto.init.call(this, firstName, lastName, birthYear);//   this.course = course;// };
// - Creating a method inside the StudentProto object -// StudentProto.introduce = function () {//   console.log(//     "My name is " +//       this.firstName +//       " " +//       this.lastName +//       "And I'm studying " +//       this.course//   );// };
// - Creating an object of Student(Child) object with StudentProto as prototype -// const jay = Object.create(StudentProto);// console.log(jay);// jay.init("Jay", "Stance", 2001, "CSE");// jay.introduce();// jay.calcAge();
// --------------------------------------------------------------------------------------------------------------------// => ENCAPSULATION AND DATA PRIVACY IN JAVASCRIPT -
// - Encapsulation, one of the principles of Object-Oriented Programming is the key to achieve such goals.// - By definition Encapsulation in JavaScript is a process of binding the data with the functions which act upon the data. Encapsulation allows us to control and validate the data. In JavaScript, variables resemble data.// - Encapsulation means information hiding i.e. the idea that the internal entities of an object should not be directly bare as public entities.  This will help restrict the unauthorized use of the variables. Instead, if the callers want to achieve a defined result it should use the public method or public entities inside the object to access the private variables of the object.
// - In object-oriented programming, properties and methods are split into two groups:// Internal interface – methods and properties, accessible from other methods of the class, but not from the outside.// External interface – methods and properties, accessible also from outside the class.
//  - Why do we need Encapsulation and Data Privacy  -// - Imagine you have an aggregation of data you need to process. One way to do it is to first decide on a data structure to represent the data. If you start with the implementation details (let’s say an array), and everything that uses it is aware of its structure, and can create tight coupling with the data structure that can make it difficult to change that implementation later. What if you eventually want to swap the array out for a stream, or a tree, or some other data structure? If everything knows the implementation, it may be too late.// - But when we encapsulate those implementation details behind a public interface, and then everything that uses the object does so only through its public interface, it’s easier to change the implementation details later.
// NOTE:// 1. To prevent the code that is outside of the class to accidentally manipulate our data inside the class.// 2. When we expose only a Small Public Interface or a Small API consisting of few Public Methods, then  we can change all the internal methods logic with more confidence. Becuase then we know, that the external code doesn't rely on the private methods of the class and any change in their logic won't break our application.// 3. Classes organized with encapsulation in mind are easier to update when implementation details change
// - How to implement Encapsulation and Data Privacy in JavaScript -
// 1. Protected Properties/Methods:// - One Way - Protected properties are usually prefixed with an underscore "_" . Since, this way of hiding data members is not truly private - We call these data members Protected properties.This is not enforced on the language level, but there’s a well-known convention between programmers that such properties and methods should not be accessed from the outside.
// 2. Private Properties/Methods:// - Another good way(Recommended as this is truly private) - to hide internal data of an object is to use the private fields. These are the fields that can be read and change only within the class they belong to. The outside world of the class cannot change private fields directly.// - The private fields are accessible only within the body of the class.// - Prefix the field name with the special symbol # to make it private, e.g. #myField. The prefix # must be kept every time you work with the field: declare it, read it, or modify it.// - Private fields do not conflict with public ones. We can have both private #waterAmount and public waterAmount fields at the same time.// - Unlike protected ones, private fields are enforced by the language itself. That’s a good thing.// - As we know, usually we can access fields using this[propertyName] or this.propertyName. With private fields that’s impossible: this['#fieldName'] or this.#fieldName doesn’t work. That’s a syntax limitation to ensure privacy.
// - And then use setter methods to set the data and getter methods to get that data be it Private or Protected.// - Or Make Public Interfaces/APIs to get and set those data.
// --------------------------------------------------------------------------------------------------------------------// => FIELDS(AKA PROPERTIES IN JAVASCRIPT) IN CLASSES/CONSTRUCTOR FUNCTIONS -
// In JavaScript, there are two types of object fields (properties and methods):// 1. Public: accessible from anywhere. They comprise the external interface. Until now we were only using public properties and methods.// 2. Private: accessible only from inside the class. These are for the internal interface.
// 3. In many other languages there also exist “protected” fields: accessible only from inside the class and those extending it (like private, but plus access from inheriting classes). They are also useful for the internal interface. They are in a sense more widespread than private ones, because we usually want inheriting classes to gain access to them.// Protected fields are not implemented in JavaScript on the language level, but in practice they are very convenient, so they are emulated.
// - Class/Constructor Functions fields are variables that hold information. Fields can be attached to 2 entities:// 1. Fields on the class/constructor function instance// 2. Fields on the class/constructor function itself (aka static)
// As we Know there are 3 kinds of Fields/Methods -// Public - These field are instance fields// Private - These field are instance fields// Protected - These field are instance fields
// - All these three Public, Private and Protected fields are instance fields and methods can be made class fields using the static keyword.// Static - Fields created using the static keyword are class level.
// Note:// 1. Instance Fields and Class Fields/Methods are not attached to the prototype of an Object.// 2. The class fields proposal lets you define the fields inside the body of the class. Plus, you can indicate the initial value right away.// 3. A static field must be defined in CAPITAL_SNAKE_CASE as a convention and static method in camelCase.
// - Difference between Fields and Properties -// 1. Instance properties declared inside constructor while instance fields are declared inside a class.// 2. A public field is an instance property, just one created with a field definition rather than by assignment. Other than how they're created, they're exactly the same thing.// 3. The term "field" was used so it could cover both public and private (since private fields are not properties).
// --------------------------------------------------------------------------------------------------------------------// => 1. ENCAPSULATION AND DATA PRIVACY USING PROTECTED DATA MEMBERS -
// class Account {//   constructor(owner, currency, pin) {//     this.owner = owner;//     this.currency = currency;
//     // Protected properties//     this._movements = [];//     this._pin = pin;
//     this.locale = navigator.language;//     console.log(`Thanks for opening an account, ${owner}`);//   }
// Public interface// Creating a Public method to access the Protected Properties(Though we still can access it directly using the _movements but user won't know about that.)// Here, instead of creating a public method to get the movements we can also create getters and setters.// getMovements() {//   console.log(this._movements);//   return this._movements;// }
// Protected Method// _approveLoan(val) {//   return true;// }
// More Public Methods/Interfaces to access the Protected Properties/Methods//   requestLoan(val) {//     if (this._approveLoan(val)) {//       this.deposit(val);//       console.log(`Loan approved`);//       return this;//     }//   }//   deposit(val) {//     this._movements.push(val);//   }//   withdraw(val) {//     this.deposit(-val);//     return this;//   }// }
// const acc1 = new Account("Jonas", "EUR", 1111);// acc1.deposit(250);// acc1.withdraw(140);// acc1.requestLoan(1000);// console.log(acc1);
// Accessing Public Method/Interface// acc1.getMovements();
// --------------------------------------------------------------------------------------------------------------------// => 2. ENCAPSULATION AND DATA PRIVACY USING PRIVATE DATA MEMBERS -
// Example -
// class Account {// 1. Public Fields (instances) -// locale = navigator.language;
// 2. Private Fields (instances) -// #movements = [];// #pin;
// 3. Static Fields (classes) -// static BANK_NAME = "BOI";
// constructor(owner, currency, pin) {//   this.owner = owner;//   this.currency = currency;
// Setting the private property using a constructor. But we have first declare it outside of the constructor.Otherwise it wont work because we cannot declare fields inside a constructor.//   this.#pin = pin;
//   console.log(`Thanks for opening an account, ${owner}`);// }
// 4. Public Methods / Public interface (instance) -// Here, instead of creating a public method to get the movements we can also create getters and setters.// getMovements() {//   console.log(this.#movements);//   return this.#movements;// }
// 5. Private Method -// #approveLoan(val) {//   return true;// }
// 6. Static Method -// static helperMethod() {//   console.log("Helper Static Method");// }
// More Public Methods/Interfaces to access the Private Properties/Methods//   requestLoan(val) {//     if (this.#approveLoan(val)) {//       this.deposit(val);//       console.log(`Loan approved`);//       return this;//     }//   }//   deposit(val) {//     this.#movements.push(val);//   }//   withdraw(val) {//     this.deposit(-val);//     return this;//   }// }
// const acc1 = new Account("Jonas", "EUR", 1111);// acc1.deposit(250);// acc1.withdraw(140);// acc1.requestLoan(1000);// console.log(acc1);
// Accessing Public Method/Interface// acc1.getMovements();
// Accessing Static fields// console.dir(Account.BANK_NAME);
// Accessing Static Method// Account.helperMethod();
// Can't access the private fields/methods now even if we want to unlike protected fields// console.log(acc1.#movements);// console.log(acc1.#pin);// acc1.#approveLoan();
// -------------------------------------------------------------------------------------------------------------------// => IMPLEMENTING METHOD CHAINING ON OUR OWN OBJECTS, CLASSES OR FUNCTIONS -
// - As a good programming practice, we should write individual functions/methods for dealing with individual actions. And, writing only one method/function for all actions is a thing. However, sticking to good practice takes a toll on the readability and comprehensibility of the code, because defining a separate function for each action means that the output of a single function/method is input. This makes code comprehensibility even worse, as the function needs to be nested in reverse order. This is where method chaining comes to the rescue.
// - Method Chaining is a programming strategy that simplifies and embellishes your code. It is a mechanism of calling a method on another method of the same object.
// - "this" keyword in JavaScript refers to the current object in which it is called. Thus, when a method returns "this", it simply returns an instance of the object in which it is returned. Since the returned value is an instance of an object, it is, therefore, possible to call another method of an object to the returned value, which is its instance. And this makes method chaining possible in JavaScript.
// Example: In this example, each method in Land.prototype returns this, which refers to the entire instance of that Land object. And this would help in calling a method on another method of the same object.
// Creating a constructor function Land()// function Land() {//   this.area = "";//   this.status = "for Sale";// }// Setting status open for sale// Land.prototype.open = function () {//   this.status = "Open for Sale";//   return this;// };// Setting status not for sale// Land.prototype.close = function () {//   this.status = "Not for Sale";//   return this;// };// Setting Parameters// Land.prototype.setParams = function (area) {//   this.area = area;//   return this;// };// printing land status// Land.prototype.doorStatus = function () {//   console.log("The", this.area, "Land is", this.status);//   return this;// };// creating a land object// var land = new Land();// console.log(land);// land.setParams("500 sq ft").close().doorStatus().open().doorStatus();
