// ASYNCHRONOUS JAVASCRIPT -// -> Hoisting in JS// -> Scope Chain// -> Lexical Scope// -> Use Strict Mode// -> This keyword// -> Closure in JS// -> What is ASYNCHRONOUS JAVASCRIPT Programming// -> What is Event Loop?
// ---------------------------------------------------------------------------------------------------// 1. HOISTING IN JS -
// We have a creation phase and execution phase in JS.// Hoisting in Javascript is a mechanism where variables and functions declarations are moved to the top of their scope before the code executes in the creation phase.
// For example -// console.log(myName);// var myName;// myName = "John Smith";
// How the above code will execute it during the creation phase.// 1. var myName = undefined;// 2. console.log(myName);// 3. myName = "John Smith";
// NOTE : In ECMAScript2016 or ES6, hoisting is avoided by using the let and const keyword instead of using the var keyword. So, If we use let or const for the declarations of a variable/function then the hoisting mechanism won't apply to that variable or function declaration and it will throw error.
// ---------------------------------------------------------------------------------------------------//2.  Scope Chain and Lexical Scope in JavaScript -
// -> The scope chain is used to resolve the value of variable names in JS.// -> Scope Chain in JS is lexically defined, which means that we can see what the scope chain will be by looking at the code.// -> At the top level, we have the global scope, which is the window object in the browser.// -> Lexical Scoping means, the inner function can get access to their parent functions variables But vice versa is not true.
// ---------------------------------------------------------------------------------------------------//3. Closure in JavaScript -
// -> A closure is a combination of a function bundled together (enclosed) with references to its surrounding state (the lexical environment). Basically, closure store the references of its parent variables and argument passed to its inner function so, that their values can be used later even its parent excution is completed.// -> In other words, a closure gives you access to an outer function's scope from an inner function.// -> In JavaScript, closures are created every time a function is created, at function creation time.
// For example -// -> Its same like Lexical Scoping.// But what is difference between Lexical Scoping and Closure? Search online.
// Note : Run this code in browser console to see the closure values.// const outerFun = (a) => {//   let b = 10;//   const innerFun = () => {//     let sum = a + b;//     console.log(sum);//   };//   return innerFun;// };// // outerFun(5);// let checkClosure = outerFun(5);// console.dir(checkClosure); // It is console.log() with more details.
// ---------------------------------------------------------------------------------------------------// Function Curring -
// What is function Curring?// Curring is a technique of evaluating functions with multiple arguments, into a sequence of functions with single arguments.// In other words, when a functionm instead of taking all arguments at one single time, takes the first one and returns a new function that takes the second one and returns a new function that takes the third one, and so forth, untill all the arguments have been passed.// That is when we turn a function call add(1,2,3) into add(1)(2)(3).
// ONE WAY -// function sum(a) {//   return function (b) {//     return function (c) {//       console.log(a + b + c);//     };//   };// }
// ANOTHER WAY - Using fat arrow.// const sum = (a) => (b) => (c) => console.log(a + b + c);
// sum(4)(5)(6);
//---------------------------------------------------------------------------------------------------// Synchronous and Asynchronous Javascript -
// Defination, example and the difference between them.
// ---------------------------------------------------------------------------------------------------// EVENT LOOP -
// What is Execution Context and Execution Stack?
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// => SYNCHRONOUS AND ASYNCHRONOUS CODE IN JAVASCRIPT -
// - Synchronous Code -// 1. Most code in JavaScript is Synchronous. Every synchronous code is executed using Execution thread which is  part of Execution Context that actually executes the code on Computer's CPU// 2. Synchronous code is executed line by line// 3. Each line of code waits for the previous line to finish execution.Asynchronous
// - Asynchronous Code -// 1. Asynchronous code is executed after a task that runs in that runs in the background finishes.// 2. Asynchronous code is NON BLOCKING.// 3. Execution thread does not wait for an Asynchronous Code to finish its work.
// Note - ASYNCHRONOUS CODE is majorly used in Web APIs and AJAX calls.
// ---------------------------------------------------------------------------------------------------------------------// => AJAX AND AJAX CALLS -
// - AJAX stands for Asynchronous JavaScript and XML : Allows us to communicate with Remote Web Servers in an Asynchronous way.// - With AJAX calls, we can request data from Web Servers dynamically and be able to update the data on on our application without reloading the webpages// - AJAX calls requests are made using HTTP methods from the Client to the Web Server for sending and recieving the data.// - The Webserver usually contains a Web API that has the data that the client requests to fullfill the client requests with responses.
// --------------------------------------------------------------------------------------------------------------------// => API -
// -  FRom Internet
// ---------------------------------------------------------------------------------------------------------------------// => MAKING AJAX CALLS -
// There are two ways to Make AJAX calls -// 1. XMLHttpRequest() API (Old Way)// 2. fetch() API (Modern Way)
// Note -// 1. Run the Ajax.html file in Ajax folder to see it in working.// 2.
// - Rest From Internet
// ---------------------------------------------------------------------------------------------------// => CALLBACK HELL -
// What is callback Hell and how promises helps us to resolve them?// Escaping Callback Hell using promises
// ----------------------------------------------------------------------------------------------------// => WHAT ARE PROMISES -
// - A promise is an object that is used as a placeholder for the future result of an Asynchronous Operation.// - Basically, A promise is container for an Asynchronously delivered value.// - In a less formal way, A promise is a container for a value which we might recieve in future.// - And the perfect example of this future value is - A response from an AJAX Call. So, when we start the AJAX call,there is no value yet, but we know that there will be some value in the future. And so we can use a promise to handle this future value.// - Promises are ES6 features.
// => Analogy Example -// - To understand this concept even better, We can use the analogy of a lottery ticket.// - So a promise is just like a lottery ticket. So when I buy a lottery ticket, essentially I buy the promise that I will receive some amount of money in the future if I guess the correct outcome, right?// - So I buy the ticket now with the prospect of winning money in the future and the lottery draw which determines if I get the money or not happens asynchronously. So of course I don't have to drop everything and keep waiting until the lottery draw happens, right?// - Now, in case I did get the correct outcome, then I will receive my money because I have my lottery ticket, which is the promise that I bought.// - In case, I don't win the lottery I Simply do nothing with regards to lottery ticket and try to do others tasks.
// => Advantages -// - There are 2 major advantages of Promises -// 1. By using promises, we no longer need to rely on events and callback functions to handle asynchronous results, events and callback functions can sometimes cause unpredictable results.// 2. With promises, we can chain promises for a sequence of asynchronous operations instead of nesting. And with this, we can finally escape callback hell.
// --------------------------------------------------------------------------------------------------------------------// => PROMISES LIFECYCLE -
// - Since promises work with asynchronous operations, they are time sensitive. So they change over time. And so promises can be in different states and this is what they call the cycle of a promise.
// => Lifecycle -// 1. So in the very beginning, we say that a promise is pending. So this is before any value resulting from the asynchronous task is available.// 2. During this time, the asynchronous task is still doing its work in the background.// 3 Then, when the task finally finishes, we say that the promise is settled and there are two different types of settled promises -//     i)  - Fulfilled Promises//     ii) - Rejected Promises
// 4. A Fulfilled Promise is a promise that has successfully resulted in a value just as we expect it. For example,  when we use the promise to fetch data from an API, a fulfilled promise successfully guts that data, and it's now available to being used.// 5. A Rejected Promise means that there has been an error during the asynchronous task. And the example of fetching data from an API, an error would be - when the user is offline and can't connect to the API server.// 6. These different states of Promises here are relevant and useful when we use a promise to get a result, which is called - TO CONSUME A PROMISE.// - So, we consume a promise when we already have a promise, for example - The promise that was returned from the fetch function, right at the beginning of this video, remember. But in order for a promise to exist in the first place, it must first be built.
// => Analogy Example -// - Now going back to the analogy of our lottery ticket, the lottery draw is basically the asynchronous task, which determines the result.// - Then once the result is available, the ticket would be settled. Then if we guessed the correct outcome, the lottery ticket will be fulfilled and we get our money.// - However, if we guessed wrong, then the ticket basically gets rejected. And all we did was waste our money.
// Note:// - Now these different states are very important to understand because when we use promises in our code, we will be able to handle these different states in order to do something as a result of either a successful promise or a rejected one.// - Another important thing about promises is that a promise is only settled once. And so from there, the state will remain unchanged forever. So the promise was either fulfilled or rejected, but it's impossible to change that state.// - States of Promises -//   1. Unresolved or Pending — A Promise is pending if the result is not ready. That is, it’s waiting for something to finish (for example, an async operation).//   2. Resolved or Fulfilled — A Promise is resolved if the result is available. That is, something finished (for example, an async operation) and all went well.//   3. Rejected — A Promise is rejected if an error happened.
// ---------------------------------------------------------------------------------------------------------------------// => CREATING/BUILDING AND CONSUMING PROMISES -
// [A] => Creating  A Promise -// - Most of the times you will be consuming promises rather than creating them, but it’s still important to know how to create them.// - We create a new promise using the Promise constructor it takes a single argument, a callback, also known as Executor Function.// - This Executor Function takes two callbacks - resolve and reject.// - The Executor Function is immediately executed when a promise is created.// - Now this Executor Function that we specified is the function which will contain the asynchronous behavior that we're trying to handle with the promise. So this executor function should eventually produce a result value. And This value is basically what's going to be the future value of the promise.// - The promise is resolved by calling the resolve() and rejected by calling reject().// - The resolve() and reject() takes one argument which can be a string, number, boolean, array or object.
// - The promise object returned by the new Promise constructor has these internal properties:// 1. state —//       - Initially "pending",//       - Then changes to either "fulfilled" when resolve is called//       - Or "rejected" when reject is called.// 2. result —//       - Initially undefined,//       - Then changes to value when resolve(value) called//       - Or error when reject(error) is called.
// Note —// - A promise can be resolved or rejected only once. Further invocation of resolve() or reject() has no effect on Promise state.// - A Resolve function will provide the fulfulled result of the promise that will be available in the then() handler.// - A Reject function will provide the rejected result of the promise that will be available in the catch() handler.// - The properties state and result of the Promise object are internal. We can’t directly access them. We can use the methods .then/.catch/.finally for that.
// - Lottery Example -// Creating a lotteryPromise object using the Promise constructor.// const lotteryPromise = new Promise(function(resolve, reject){//   - Synchronous Promise//   if(Math.random() >= 0.5){//     resolve("You Won the Lottery ")//   }//   else{//     reject("You Lost ")//   }// })
// - However the code we wrote above is not Asynchronous yet. We can make this code asynchronous adding event function which works asynchronously like setTimeout(), onLoad(), onError() etc.// - Asynchronous Lottery Example -// const lotteryPromise = new Promise(function (resolve, reject) {//   console.log("Lottery draw is happening... ");//   - Encapsulating Asynchronouse behaviour in our Promise.//   setTimeout(function () {//     if (Math.random() >= 0.5) {//       resolve("You Won the Lottery ");//     } else {//       reject(new Error("You Lost "));//     }//   }, 2000);// });
// [B] => Consuming A Promise -
// - A Promise object serves as a link between the executor (the “producing code” or “singer”) and the consuming functions (the “fans”), which will receive the result or error. Consuming functions can be registered (subscribed) using methods .then, .catch and .finally.
// => Consumers -// 1. .then() -// - The most important, fundamental one is .then()// - The first argument of .then is called a SuccessfulCallback Function that runs when the promise is resolved, and receives the result. It takes one argument which is the FulFillment Value passed to resolve().// - The second argument of .then is called a FailureCallback Function that runs when the promise is rejected, and receives the error. It takes one argument which is the Rejected Value passed to reject().// - The then() method always returns a promise, no matter if we actually return anything or not. But if we do return a value, then that value will become the Fulfillment Value of the return promise.// - Syntax: promiseObject.then(successCallback, failureCallback)
// - Lottery Example -// Using the lotteryPromise to handle the response from the promise.// lotteryPromise.then(//   function (response) {//     console.info(response);//   },//   function (error) {//     console.log(error);//   }// );
// 2. .catch() -// - If we’re interested only in errors, then we can use null as the first argument: .then(null, errorHandlingFunction). Or we can use .catch(errorHandlingFunction)// - The call .catch(f) is a complete analog of .then(null, f), it’s just a shorthand.// - We use catch() for handling just errors. It’s more readable than handling errors inside the failureCallback callback of the then() callback.// - Syntax: promise.catch(failureCallback)
// - Lottery Example -// Using the lotteryPromise to handle the response from the promise.// lotteryPromise//   .then(function (response) {//     console.info(response);//   })//   .catch(function (response) {//     console.info(response);//   });
// 3. .finally() -// - A finally handler has no arguments. In finally we don’t know whether the promise is successful or not. That’s all right, as our task is usually to perform “general” finalizing procedures.// - A finally handler passes through results and errors to the next handler.// - finally handler is not meant to process a promise result. So the result which is before the finally handler passes it through to the handler next to finally.
// - Lottery Example -// lotteryPromise//   .then(function (response) {//     console.info(response);//   })//   .finally(function () {//     console.log("Promise ready");//   })//   .catch(function (response) {//     console.info(response);//   });
// ---------------------------------------------------------------------------------------------------------------------// - PROMISE CHAINING -
// - The then() and catch() methods can also return a new promise which can be handled by chaining another then() at the end of the previous then() method.// - We use promise chaining when we want to resolve promises in a sequence.// - This is one of the greatest advantages of using Promises// - If there are multiple async operations to be done and if we try to use good-old Callbacks for them, we’ll find ourselves quickly inside a situation called Callback hell.
// - Example -// const promise1 = new Promise((resolve, reject) => {//   resolve('Promise1 resolved');// });// const promise2 = new Promise((resolve, reject) => {//   resolve('Promise2 resolved');// });// const promise3 = new Promise((resolve, reject) => {//   reject('Promise3 rejected');// });// promise1//   .then((data) => {//     console.log(data);  // Promise1 resolved//     return promise2;//   })//   .then((data) => {//     console.log(data);  // Promise2 resolved//     return promise3;//   })//   .then((data) => {//     console.log(data);//   })//   .catch((error) => {//     console.log(error);  // Promise3 rejected//   });
// - So what’s happening here? -// - When promise1 is resolved, the then() method is called which returns promise2.// - The next then() is called when promise2 is resolved which returns promise3.// - Since promise3 is rejected, the next then() is not called instead catch() is called which handles the promise3 rejection.// Note: Generally only one catch() is enough for handling rejection of any promise in the promise chain, if it’s at the end of the chain.
// - A Common Mistake -// - A lot of beginners make the mistake of nesting promises inside another promise.// - Example -// const promise1 = new Promise((resolve, reject) => {//   resolve('Promise1 resolved');// });// const promise2 = new Promise((resolve, reject) => {//   resolve('Promise2 resolved');// });// const promise3 = new Promise((resolve, reject) => {//   reject('Promise3 rejected');// });// promise1.then((data) => {//   console.log(data);  // Promise1 resolved//   promise2.then((data) => {//     console.log(data);  // Promise2 resolved
//     promise3.then((data) => {//       console.log(data);//     }).catch((error) => {//       console.log(error);  // Promise3 rejected//     });//   }).catch((error) => {//     console.log(error);//   })// }).catch((error) => {//     console.log(error);// });
// - Although this works fine, this is considered to be a poor style and makes our code difficult to read. If you have a sequence of promises to resolve, it’s better to chain promises one after another rather than nest one inside another. And if we do it like this, then I think we are simply diving into CallBack Hell and defeating the purpose of using Promises in the first place.// ---------------------------------------------------------------------------------------------------------------------// - PROMISIFYING A FUNCTION -
// - In practice, most of the time all we actually do is to consume promises. And we usually only built promises to basically wrap old callback based functions into promises. And this is a process that we call PROMISIFYING.// - So basically promisifying means to convert callback based asynchronous behavior to promise based.
// - So to promisify a function, we create a function and inside of that function we will actually create and return the promise. So usually that's always what we do.// - This creating of a function and then from there returning a promise will then encapsulate the asynchronous  operation even further. And this what essentially a fetch function does. It's a function that returns a promise.
// - Example -// - Creating a Promisifying Function wait() which will simply wait for sometime before resolving -// const wait = function (seconds) {// Only using the resolve function and not the reject function because there is no way a Timer function can fail.//   return new Promise(function (resolve) {// We don't need to pass any resolve() function value as we are just making a waiting function, so we just simply pass the resolve() function which will be called by setTimeout after the timer.//     setTimeout(resolve, seconds * 1000);//   });// };
// console.log("Promise Started");// - Consuming our promisify function promise -// The fulfilledCallback function of then is empty because we didn't pass any resolve() value while creating this promise.// wait(2)//   .then(() => {//     console.log("Waited for 2 seconds");// - Chaining our Promise -//     return wait(3);//   })//   .then(() => {//     console.log("Waited for 3 seconds");//     console.log("Promise Complete");//   });
// ---------------------------------------------------------------------------------------------------------------------// - SHORTHAND PROMISES -
// - There is a easier way to create Resolve and Reject promises using the Static resolve() and reject() methods of Promise constructor.// - These promises created with the static methods are resolved immediately after creation.
// -Example -// Promise.resolve("Resolved Promise").then((res) => console.log(res));// Promise.reject(new Error("Rejected Promise")).then((err) => console.error(err));
//--------------------------------------------------------------------------------------------------------------------// => CALLBACK VS PROMISES -
// - Promises are similar to callback functions in a sense that they both can be used to handle asynchronous tasks.// - JavaScript callback functions can also be used to perform synchronous tasks.
// - JavaScript Promise -// - The syntax is user-friendly and easy to read.// - Error handling is easier to manage.
// - JavaScript Callback// - The syntax is difficult to understand.// - Error handling may be hard to manage.
// ---------------------------------------------------------------------------------------------------------------------// => CONSUMING PROMISES BETTER APPROACH - ASYNC/AWAIT (ECMASCRIPT2017 -ES8) -
// Note: Async-Await is in fact, simply syntactic sugar over the then method in Promises. So of course behind the scenes, we are still using Promises. We are simply using a different way of consuming them.
